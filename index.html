<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Neon Grid Blaster</title>
<style>
  * { margin: 0; padding: 0; box-sizing: border-box; }
  body {
    background: #0a0a1a;
    display: flex;
    justify-content: center;
    align-items: center;
    min-height: 100vh;
    font-family: 'Segoe UI', sans-serif;
    overflow: hidden;
    user-select: none;
  }
  #game {
    display: flex;
    flex-direction: column;
    align-items: center;
    gap: 20px;
  }
  #header {
    display: flex;
    justify-content: space-between;
    width: 400px;
    color: #fff;
    align-items: center;
  }
  h1 {
    font-size: 24px;
    background: linear-gradient(90deg, #ff006e, #8338ec, #3a86ff);
    -webkit-background-clip: text;
    -webkit-text-fill-color: transparent;
    text-transform: uppercase;
    letter-spacing: 3px;
  }
  #score-display {
    font-size: 20px;
    color: #3a86ff;
    text-shadow: 0 0 10px #3a86ff55;
  }
  #board {
    position: relative;
    background: #12122a;
    border: 2px solid #1a1a3a;
    border-radius: 12px;
    padding: 5px;
    box-shadow: 0 0 40px #3a86ff15, inset 0 0 60px #00000055;
  }
  canvas { display: block; border-radius: 8px; }
  #pieces-area {
    display: flex;
    justify-content: center;
    gap: 30px;
    min-height: 120px;
    align-items: center;
    background: #12122a;
    border-radius: 12px;
    padding: 15px 25px;
    border: 2px solid #1a1a3a;
    width: 400px;
  }
  .piece-holder {
    cursor: grab;
    padding: 5px;
    border-radius: 8px;
    transition: transform 0.15s, box-shadow 0.15s;
  }
  .piece-holder:hover {
    transform: scale(1.1);
    box-shadow: 0 0 15px #ffffff22;
  }
  .piece-holder.dragging {
    opacity: 0.3;
    transform: scale(0.9);
  }
  #drag-preview {
    position: fixed;
    pointer-events: none;
    z-index: 1000;
    opacity: 0.8;
    display: none;
  }
  #game-over {
    display: none;
    position: fixed;
    inset: 0;
    background: #0a0a1aee;
    z-index: 100;
    flex-direction: column;
    justify-content: center;
    align-items: center;
    gap: 20px;
  }
  #game-over.show { display: flex; }
  #game-over h2 {
    font-size: 48px;
    color: #ff006e;
    text-shadow: 0 0 30px #ff006e88;
  }
  #game-over p { color: #aaa; font-size: 22px; }
  #restart-btn {
    padding: 12px 40px;
    font-size: 18px;
    border: 2px solid #3a86ff;
    background: transparent;
    color: #3a86ff;
    border-radius: 30px;
    cursor: pointer;
    transition: all 0.2s;
    letter-spacing: 2px;
  }
  #restart-btn:hover {
    background: #3a86ff;
    color: #0a0a1a;
    box-shadow: 0 0 20px #3a86ff66;
  }
  #combo-text {
    position: fixed;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    font-size: 60px;
    font-weight: bold;
    pointer-events: none;
    z-index: 50;
    opacity: 0;
    transition: none;
    text-shadow: 0 0 30px currentColor;
  }
  #streak { color: #fb5607; font-size: 16px; min-width: 80px; text-align: right; }
</style>
</head>
<body>

<div id="game">
  <div id="header">
    <h1>Neon Blaster</h1>
    <span id="streak"></span>
    <span id="score-display">0</span>
  </div>
  <div id="board">
    <canvas id="canvas"></canvas>
  </div>
  <div id="pieces-area"></div>
</div>

<div id="drag-preview"><canvas id="drag-canvas"></canvas></div>
<div id="combo-text"></div>

<div id="game-over">
  <h2>GAME OVER</h2>
  <p>Score: <span id="final-score">0</span></p>
  <button id="restart-btn" onclick="initGame()">PLAY AGAIN</button>
</div>

<script>
const COLS = 8, ROWS = 8, CELL = 46, GAP = 3;
const SIZE = COLS * (CELL + GAP) + GAP;

const COLORS = [
  { fill: '#ff006e', glow: '#ff006e55', light: '#ff4d94' },
  { fill: '#3a86ff', glow: '#3a86ff55', light: '#6ea8ff' },
  { fill: '#8338ec', glow: '#8338ec55', light: '#a96bf2' },
  { fill: '#fb5607', glow: '#fb560755', light: '#fc8443' },
  { fill: '#ffbe0b', glow: '#ffbe0b55', light: '#ffd24d' },
  { fill: '#06d6a0', glow: '#06d6a055', light: '#3de8be' },
];

const SHAPES = [
  [[1]],
  [[1,1]],
  [[1],[1]],
  [[1,1,1]],
  [[1],[1],[1]],
  [[1,1],[1,1]],
  [[1,1,1],[1,0,0]],
  [[1,1,1],[0,0,1]],
  [[1,0],[1,1]],
  [[0,1],[1,1]],
  [[1,1],[1,0]],
  [[1,1],[0,1]],
  [[1,1,1],[0,1,0]],
  [[1,0],[1,0],[1,1]],
  [[0,1],[0,1],[1,1]],
  [[1,1,1,1]],
  [[1],[1],[1],[1]],
  [[1,1,1],[1,1,1]],
  [[1,1],[1,1],[1,1]],
  [[1,0,0],[1,0,0],[1,1,1]],
  [[0,0,1],[0,0,1],[1,1,1]],
  [[1,1,1],[0,0,1],[0,0,1]],
  [[1,1,1],[1,0,0],[1,0,0]],
  [[1,1,1,1,1]],
  [[1],[1],[1],[1],[1]],
  [[1,1,1],[1,1,1],[1,1,1]],
];

const canvas = document.getElementById('canvas');
const ctx = canvas.getContext('2d');
canvas.width = canvas.height = SIZE;

let grid, score, pieces, streak, gameOver;
let dragPiece = null, dragX = 0, dragY = 0, hoverPos = null;
let particles = [];
let clearingCells = [];

function initGame() {
  grid = Array.from({length: ROWS}, () => Array(COLS).fill(0));
  score = 0; streak = 0; gameOver = false;
  particles = []; clearingCells = [];
  document.getElementById('game-over').classList.remove('show');
  updateScore();
  spawnPieces();
  draw();
}

function randomPiece() {
  const shape = SHAPES[Math.floor(Math.random() * SHAPES.length)];
  const color = COLORS[Math.floor(Math.random() * COLORS.length)];
  return { shape, color };
}

function spawnPieces() {
  pieces = [randomPiece(), randomPiece(), randomPiece()];
  renderPieceHolders();
  checkGameOver();
}

function renderPieceHolders() {
  const area = document.getElementById('pieces-area');
  area.innerHTML = '';
  pieces.forEach((piece, i) => {
    if (!piece) return;
    const holder = document.createElement('div');
    holder.className = 'piece-holder';
    const c = document.createElement('canvas');
    const rows = piece.shape.length, cols = piece.shape[0].length;
    const miniCell = 18, miniGap = 2;
    c.width = cols * (miniCell + miniGap) + miniGap;
    c.height = rows * (miniCell + miniGap) + miniGap;
    const cx = c.getContext('2d');
    for (let r = 0; r < rows; r++)
      for (let cl = 0; cl < cols; cl++)
        if (piece.shape[r][cl]) {
          const x = miniGap + cl * (miniCell + miniGap);
          const y = miniGap + r * (miniCell + miniGap);
          cx.fillStyle = piece.color.fill;
          cx.shadowColor = piece.color.glow;
          cx.shadowBlur = 6;
          cx.beginPath();
          cx.roundRect(x, y, miniCell, miniCell, 3);
          cx.fill();
          cx.shadowBlur = 0;
          cx.fillStyle = piece.color.light;
          cx.globalAlpha = 0.3;
          cx.fillRect(x+2, y+2, miniCell-4, miniCell/3);
          cx.globalAlpha = 1;
        }
    holder.appendChild(c);
    holder.addEventListener('mousedown', (e) => startDrag(i, e.clientX, e.clientY));
    holder.addEventListener('touchstart', (e) => {
      e.preventDefault();
      startDrag(i, e.touches[0].clientX, e.touches[0].clientY);
    }, {passive:false});
    area.appendChild(holder);
  });
}

function startDrag(index, x, y) {
  if (!pieces[index]) return;
  dragPiece = { index, piece: pieces[index] };
  dragX = x; dragY = y;
  const holders = document.querySelectorAll('.piece-holder');
  if (holders[index]) holders[index].classList.add('dragging');

  const preview = document.getElementById('drag-preview');
  const dc = document.getElementById('drag-canvas');
  const p = dragPiece.piece;
  const rows = p.shape.length, cols = p.shape[0].length;
  dc.width = cols * (CELL + GAP) + GAP;
  dc.height = rows * (CELL + GAP) + GAP;
  const cx = dc.getContext('2d');
  for (let r = 0; r < rows; r++)
    for (let c = 0; c < cols; c++)
      if (p.shape[r][c]) drawBlock(cx, c, r, p.color, 1, CELL, GAP);
  preview.style.display = 'block';
  moveDragPreview(x, y);
}

function moveDragPreview(x, y) {
  const preview = document.getElementById('drag-preview');
  const dc = document.getElementById('drag-canvas');
  preview.style.left = (x - dc.width/2) + 'px';
  preview.style.top = (y - dc.height - 20) + 'px';
  
  const rect = canvas.getBoundingClientRect();
  const bx = x - rect.left, by = y - rect.top - dc.height/2 - 20;
  const col = Math.round((bx - GAP) / (CELL + GAP));
  const row = Math.round((by - GAP) / (CELL + GAP));
  
  if (canPlace(dragPiece.piece.shape, row, col)) {
    hoverPos = {row, col};
  } else {
    hoverPos = null;
  }
  draw();
}

function endDrag() {
  if (!dragPiece) return;
  document.getElementById('drag-preview').style.display = 'none';
  const holders = document.querySelectorAll('.piece-holder');
  holders.forEach(h => h.classList.remove('dragging'));
  
  if (hoverPos) {
    placePiece(dragPiece.piece, hoverPos.row, hoverPos.col);
    pieces[dragPiece.index] = null;
    renderPieceHolders();
    clearLines();
    if (pieces.every(p => p === null)) spawnPieces();
    else checkGameOver();
  }
  dragPiece = null;
  hoverPos = null;
  draw();
}

document.addEventListener('mousemove', (e) => {
  if (dragPiece) moveDragPreview(e.clientX, e.clientY);
});
document.addEventListener('mouseup', endDrag);
document.addEventListener('touchmove', (e) => {
  if (dragPiece) { e.preventDefault(); moveDragPreview(e.touches[0].clientX, e.touches[0].clientY); }
}, {passive:false});
document.addEventListener('touchend', endDrag);

function canPlace(shape, row, col) {
  for (let r = 0; r < shape.length; r++)
    for (let c = 0; c < shape[0].length; c++)
      if (shape[r][c]) {
        const gr = row + r, gc = col + c;
        if (gr < 0 || gr >= ROWS || gc < 0 || gc >= COLS || grid[gr][gc]) return false;
      }
  return true;
}

function placePiece(piece, row, col) {
  for (let r = 0; r < piece.shape.length; r++)
    for (let c = 0; c < piece.shape[0].length; c++)
      if (piece.shape[r][c])
        grid[row + r][col + c] = piece.color;
}

function clearLines() {
  let fullRows = [], fullCols = [];
  for (let r = 0; r < ROWS; r++)
    if (grid[r].every(c => c)) fullRows.push(r);
  for (let c = 0; c < COLS; c++) {
    let full = true;
    for (let r = 0; r < ROWS; r++) if (!grid[r][c]) { full = false; break; }
    if (full) fullCols.push(c);
  }
  
  const linesCleared = fullRows.length + fullCols.length;
  if (linesCleared === 0) { streak = 0; updateScore(); return; }
  
  streak++;
  let toClear = new Set();
  fullRows.forEach(r => { for (let c = 0; c < COLS; c++) toClear.add(r+','+c); });
  fullCols.forEach(c => { for (let r = 0; r < ROWS; r++) toClear.add(r+','+c); });
  
  toClear.forEach(key => {
    const [r,c] = key.split(',').map(Number);
    spawnParticles(c, r, grid[r][c]);
    clearingCells.push({r, c, alpha: 1, color: grid[r][c]});
  });
  
  const pts = toClear.size * 10 * (streak > 1 ? streak : 1);
  score += pts;
  
  if (streak > 1) showCombo(streak);
  
  setTimeout(() => {
    toClear.forEach(key => {
      const [r,c] = key.split(',').map(Number);
      grid[r][c] = 0;
    });
    draw();
  }, 200);
  
  updateScore();
}

function showCombo(n) {
  const el = document.getElementById('combo-text');
  const colors = ['#ff006e','#ffbe0b','#06d6a0','#3a86ff','#8338ec'];
  el.style.color = colors[n % colors.length];
  el.textContent = `${n}x COMBO!`;
  el.style.opacity = 1;
  el.style.transform = 'translate(-50%, -50%) scale(1.5)';
  el.style.transition = 'none';
  requestAnimationFrame(() => {
    el.style.transition = 'all 0.8s ease-out';
    el.style.opacity = 0;
    el.style.transform = 'translate(-50%, -80%) scale(2)';
  });
}

function spawnParticles(col, row, color) {
  const cx = GAP + col * (CELL + GAP) + CELL/2;
  const cy = GAP + row * (CELL + GAP) + CELL/2;
  for (let i = 0; i < 6; i++) {
    const angle = Math.random() * Math.PI * 2;
    const speed = 1 + Math.random() * 3;
    particles.push({
      x: cx, y: cy,
      vx: Math.cos(angle) * speed,
      vy: Math.sin(angle) * speed,
      life: 1,
      color: color.fill,
      size: 3 + Math.random() * 4,
    });
  }
}

function checkGameOver() {
  const remaining = pieces.filter(p => p !== null);
  for (const p of remaining) {
    for (let r = 0; r < ROWS; r++)
      for (let c = 0; c < COLS; c++)
        if (canPlace(p.shape, r, c)) return;
  }
  if (remaining.length > 0) {
    gameOver = true;
    document.getElementById('final-score').textContent = score;
    setTimeout(() => document.getElementById('game-over').classList.add('show'), 500);
  }
}

function updateScore() {
  document.getElementById('score-display').textContent = score;
  document.getElementById('streak').textContent = streak > 1 ? `ðŸ”¥ ${streak}x` : '';
}

function drawBlock(c, col, row, color, alpha, cellSize, gap) {
  const x = gap + col * (cellSize + gap);
  const y = gap + row * (cellSize + gap);
  c.globalAlpha = alpha;
  c.fillStyle = color.fill;
  c.shadowColor = color.glow;
  c.shadowBlur = 8;
  c.beginPath();
  c.roundRect(x, y, cellSize, cellSize, 5);
  c.fill();
  c.shadowBlur = 0;
  // shine
  c.fillStyle = color.light;
  c.globalAlpha = alpha * 0.35;
  c.beginPath();
  c.roundRect(x+3, y+3, cellSize-6, cellSize*0.35, 3);
  c.fill();
  // inner border
  c.globalAlpha = alpha * 0.15;
  c.strokeStyle = '#fff';
  c.lineWidth = 1;
  c.beginPath();
  c.roundRect(x+1, y+1, cellSize-2, cellSize-2, 4);
  c.stroke();
  c.globalAlpha = 1;
}

function draw() {
  ctx.clearRect(0, 0, SIZE, SIZE);
  
  // grid background cells
  for (let r = 0; r < ROWS; r++)
    for (let c = 0; c < COLS; c++) {
      const x = GAP + c * (CELL + GAP);
      const y = GAP + r * (CELL + GAP);
      ctx.fillStyle = (r + c) % 2 === 0 ? '#181835' : '#1a1a38';
      ctx.beginPath();
      ctx.roundRect(x, y, CELL, CELL, 5);
      ctx.fill();
    }
  
  // hover ghost
  if (hoverPos && dragPiece) {
    const p = dragPiece.piece;
    for (let r = 0; r < p.shape.length; r++)
      for (let c = 0; c < p.shape[0].length; c++)
        if (p.shape[r][c])
          drawBlock(ctx, hoverPos.col + c, hoverPos.row + r, p.color, 0.35, CELL, GAP);
  }
  
  // placed blocks
  for (let r = 0; r < ROWS; r++)
    for (let c = 0; c < COLS; c++)
      if (grid[r][c]) drawBlock(ctx, c, r, grid[r][c], 1, CELL, GAP);
  
  // clearing animation
  clearingCells = clearingCells.filter(cell => {
    cell.alpha -= 0.05;
    if (cell.alpha <= 0) return false;
    drawBlock(ctx, cell.c, cell.r, cell.color, cell.alpha, CELL, GAP);
    return true;
  });
  
  // particles
  particles = particles.filter(p => {
    p.x += p.vx; p.y += p.vy; p.life -= 0.025;
    if (p.life <= 0) return false;
    ctx.globalAlpha = p.life;
    ctx.fillStyle = p.color;
    ctx.shadowColor = p.color;
    ctx.shadowBlur = 6;
    ctx.beginPath();
    ctx.arc(p.x, p.y, p.size * p.life, 0, Math.PI*2);
    ctx.fill();
    ctx.shadowBlur = 0;
    ctx.globalAlpha = 1;
    return true;
  });
  
  if (particles.length > 0 || clearingCells.length > 0) requestAnimationFrame(draw);
}

initGame();
</script>
</body>
</html>